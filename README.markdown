Meta
======

* Wrap 80 characters/line.
* Have code samples for every language feature.
* Indentation with spaces - not tabs.
* Every member of the language spec has four parts:
    * Brief description
    * Code sample (as short as possible, illustrating the feature in
        isolation)
    * Rationale
    * Limitations (optional)

Points of Contention
====================

Generics should be a language feature.

* Pros
    * How do we implement vectors without? It really should be a library
      feature until optimization concerns come into play.
* Cons
    * Simplicity. Both in reading code and in compiler implementation.
    * Have you _seen_ C++?

_ben: Perhaps they could be simplified greatly, only allowing for type
generics, rather than the giant turing-complete templates C++ has._

There should only be one way for comments to be parsed, unlike C which has two.

* Pros
    * Uniformity of source code.
    * Keeps the language simple.
* Cons
    * Line comments are nice!
    * Block comments are nice!
    * Choosing one will be a bitch.

_ben: For me, block comments are only useful when temporarily removing code.
Perhaps we should have a different language feature for that._

"void" is often used simply as a compensation for a mediocre type system. Can
this be eliminated?

_clark: I don't think so. How do we define 'no return value'?_
_ben: Agreed, though maybe change the keyword. What about void*?_

Operator overloading should be a language feature.

* Pros
    * A bignum library (or any numerical processing, really) would be elegant.
* Cons
    * Extremely hard to get right.
    * Breaks uniform function syntax, adding yet another exception to the rule.
    * Has different semantics from functions entirely! Infix expressions are
      just so alien.

_ben: Overloaded operators should have a guarantee of purity - that if the same
object is invoked with the same operator and the same parameter(s), then the
result is guaranteed._

Casting between arbitrary types should be allowed, similar to C++'s
`reinterpret_cast`.

* Pros
    * Allows for systems programming tasks such as reversing the bytes in a
      number. It can be argued that this can be done with bitshifts, but I'd
      rather have the compiler do it.
* Cons
    * Makes the compiler's job harder. Less assumptions can be made.
    * It's evil. Almost everywhere. Is there anywhere it's necessary?

_ben: Allow it, but with much greater restrictions than those of C++, like size
conformity and only allowing casting from pointers TO integer types (not back)._

Destructors. They should exist. If you agree, in what form?

* Pros
    * Resource cleanup is sane. A File struct makes sense.
* Cons
    * Destructors have a hidden control path, and they definitely don't play
      nice with exceptions or garbage collection. If neither of those become
      language features, however, then destructors seem okay.
    * How will they interact with our inheritance model?

Inline assembly.

* Pros
    * Makes the language a true systems programming language.
    * Performance concerns can be alleviated with "just write it in assembly if
      you care!"
* Cons
    * Complicates things. What could have once been undefined behavior now
      needs precise, well-documented semantics.

Language Specification
=======================

Object Model
-------------

Objects are POD (pieces of data).

    struct SomeObject
    {
        int a;
        SomeOtherObject b;
        int c;
    }

Any function taking an Object\* as its first parameter can be syntactically
used as a member function of that type. This can be extended to accomodate
a multiple-dispatch syntax.

Therefore,

    int foo(SomeObject* this, int x, int y)
    {
        ++this\c;
        return x + y + this\a;
    }

    SomeObject bar;
    int z = bar.foo(2, 3);

    SomeObject* pbar = &bar;
    z = pbar\foo(2, 3);

is entirely valid syntax.

There is only one special constructor - the default constructor. This is
defined as a function with the same name as the structure is is
constructing. All built-in structures have a default constructor, and if
one is not provided by the code, the compiler shall create one which calls
the default constructors of each element of the structure.

    struct S
    {
        int a;
        int b;
        int c;
    }

    S s; // all elements are set to zero since the default constructor
         // generated by the compiler sets all ints to zero.

    ///////////////////////////////////////////////////////////////////////////

    none S(S* this)
    {
        this\a = 1;
        this\b = 2;
        this\c = 3;
    }

    S s; // in this case, we have a default constructor. s will be { 1, 2, 3 }.

Move constructors do not exist; move constructors should be simple moving
of data. There may be some situations where this fails horribly, but I can't
think of any. y = move(x) is a compiler built-in, and is checked for
correctness whenever possible.

The \ character will replace C's -> operator. This is to reduce typing, turning
the common dereference operator into one keystroke instead of three.

    s->x    ===>    s\x

There are no references (as in "transparent" pointers).

No header files, only modules. We can probably rip off D's module system in its
entirety.

Static constructors from D still exist (likely renamed to init(), or
something similar).

Strings are vectors of chars. Conversion to C-strings will be necessary to
talk to C. Much of stdlib's string.h will have to be rewritten.

Anonymous functions can be created with the function keyword.

The "infer" keyword will replace "auto".

All built-in types will have default initialization values; if default
initialization is not wanted, there will be a keyword to prevent
initialization.

Calling conventions will be undefined from function to function; the
compiler/optimizer may choose. This can be overriden if necessary.

There is a "pure" keyword. If a function is pure and unannotated, emit a
diagnostic. If a function is annotated pure and is not, terminate compilation.

"const" stays.

Anonymous structs are a thing; members can be either named, or accessed with
array operators (tuples). A syntax still needs to be decided upon. It should
probably resemble lambdas.

n-conditionals are allowed (e.g. x < y < z = 0).

Nice interfacing with C.

Inheritance (and, by extension, polymorphism) is not a language built-in. A
vtable library will be provided by the standard library to assist in explicit
construction.

Casting away const is illegal - not undefined behavior.

Unit-testing resembles that of D, but has an API accessible from `main()` which
handles test reporting, running, etc. Possibly run tests before `main()` iff
`test_ext` has not been imported. Otherwise, don't run any tests except those
explicity run by `main()`.

Compiler Options
-----------------

* Build types
    * Debug
        * No optimizations, all asserts on.
        * Focus on code making sense in a debugger.
    * Dev (default)
        * Simple optimizations, all asserts on.
        * Focus on lowering the build->test cycle. Compilation should be
          blazing fast, but without sacrificing too much run-time speed. There
          is a delicate middle ground that the Dev build tries to find.
    * Release
        * Full optimization. All asserts on (custom hook enabled).
        * Focus on production-quality code. Build time is not important, and is
          sacrified to improve quality of shipping code. Asserts are also on,
          but can be hooked by the program to do proper error-reporting.
    * Fast
        * Full optimization. All asserts off.
        * Focus on fast code. That's it. Asserts will be off, and build time
          will be sacrificed for final runtime speed.
