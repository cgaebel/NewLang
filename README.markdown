# Meta

* Wrap 80 characters/line.
* Have code samples for every language feature.
* Indentation with spaces - not tabs.
* Every member of the language spec has four parts:
    * Brief description
    * Code sample (as short as possible, illustrating the feature in
        isolation)
    * Rationale
    * Limitations (optional)

# Language Specification

## Points of Contention

### Indentation should be used instead of braces for indicating scope.

* Pros
    * Enforces nice readability.
    * More intuitive.
* Cons
    * Less intuitive to C/C++-style programmers.
    * Less flexible.

### Generics should be a language feature.

* Pros
    * How do we implement vectors without? It really should be a library
      feature until optimization concerns come into play.
* Cons
    * Simplicity. Both in reading code and in compiler implementation.
    * Have you _seen_ C++?

_ben: Perhaps they could be simplified greatly, only allowing for simple type
generics, rather than the giant Turing-complete templates C++ has._

### There should only be one way for comments to be parsed, unlike C which has two.

* Pros
    * Uniformity of source code.
    * Keeps the language simple.
* Cons
    * Line comments are nice!
    * Block comments are nice!
    * Choosing one will be a bitch.

_ben: For me, block comments are only useful when temporarily removing code.
Perhaps we should have a different language feature for that._

### `void*` should be eliminated.

### Operator overloading should be a language feature.

* Pros
    * A bignum library (or any numerical processing, really) would be elegant.
* Cons
    * Extremely hard to get right.
    * Breaks uniform function syntax, adding yet another exception to the rule.
    * Has different semantics from functions entirely! Infix expressions are
      just so alien.

_ben: Overloaded operators should have a guarantee of purity - that if the same
object is invoked with the same operator and the same parameter(s), then the
result is guaranteed._

### Casting between arbitrary types should be allowed.

* Pros
    * Allows for systems programming tasks such as reversing the bytes in a
      number. It can be argued that this can be done with bitshifts, but I'd
      rather have the compiler do it.
* Cons
    * Makes the compiler's job harder. Less assumptions can be made.
    * It's evil. Almost everywhere. Is there anywhere it's necessary?

_ben: Allow it, but with much greater restrictions than those of C++, like size
conformity and only allowing casting from pointers TO integer types (not back)._

### Destructors. They should exist. If you agree, in what form?

* Pros
    * Resource cleanup is sane. A File struct makes sense.
* Cons
    * Destructors have a hidden control path, and they definitely don't play
      nice with exceptions or garbage collection. If neither of those become
      language features, however, then destructors seem okay.
    * How will they interact with our inheritance model?

### Inline assembly.

* Pros
    * Makes the language a true systems programming language.
    * Performance concerns can be alleviated with "just write it in assembly if
      you care!"
* Cons
    * Complicates things. What could have once been undefined behavior now
      needs precise, well-documented semantics.

## Object Model

Objects are POD (plain old data).

    struct SomeObject
    {
        int a;
        SomeOtherObject b;
        int c;
    }

Any function taking an `Object*` as its first parameter can be syntactically
used as a member function of that type. This can be extended to accomodate
a multiple-dispatch syntax.

Therefore,

    int foo(SomeObject* this, int x, int y)
    {
        ++this\c;
        return x + y + this\a;
    }

    SomeObject bar;
    int z = bar.foo(2, 3);

    SomeObject* pbar = &bar;
    z = pbar\foo(2, 3);

is entirely valid syntax.

There is only one special constructor - the default constructor. This is
defined as a function with the same name as the structure is is
constructing. All built-in structures have a default constructor, and if
one is not provided by the code, the compiler shall create one which does
nothing.

Before an object's default constructor is called, the default constructor for
all its children will be called.

    struct S
    {
        int a;
        int b;
        int c;
    }

    S s; // all elements are set to zero since the default constructor
         // generated by the compiler sets all ints to zero.

    ///////////////////////////////////////////////////////////////////////////

    S S()
    {
        S ret; // TODO: This is recursive. Fix. Do we need a different syntax?
               //       What if we had an implicit `this` parameter, which is
               //       a pointer to the object to be constructed (after its
               //       children have been)?

        ret.a = 1;
        ret.b = 2;
        ret.c = 3;

        return ret;
    }

    S s; // in this case, we have a default constructor. s will be { 1, 2, 3 }.

To define a constructor which takes arguments, you can just use an ordinary
function!

    S S(int x, int y)

        S ret; // calls the default constructor first...

        ret.a = x;
        ret.b = y;
        
        assert(ret.c == 3); // From the default constructor.

        return ret;
    }

    S s = S(9, 10);
    assert(s == { 9, 10, 3 });

### Copying and Moving Data

Copying is done automatically by the compiler when necessary, such as assigning
from an lvalue, or passing-by-value. It is done in two steps:

1. Each element of the structure is copied recursively.
2. `pcopy()` is run on the new structure.

`pcopy()` is a user-defined function defined as `void pcopy(S*)` where S is the
type of the struct you want `pcopy` to be defined for. It stands for *p*ost
*copy* since the function is run after the structure's elements have been
copied. If `pcopy()` is not defined for a structure, a blank one is generated
by the compiler.

    struct S { int a; }

    void pcopy(S* s)
    {
        s\a += 1; // increments s\a every time a copy is made.
    }

    S s;
    assert(s.a == 0); // thanks to int's default constructor

    S x = s;
    assert(x.a == 1);

    // Even though S is returned, pcopy isn't run. This is because it is
    // entirely transparent, and would just be wasted cycles.
    S returns1()
    {
        S ret;
        ret.a = 1;
        return ret;
    }

    S y = returns1();
    assert(y.a == 1);

Move constructors are not necessary, since it can be emulated by the compiler
refusing to call `pcopy()`.

### Inheritance/Polymorphism

Inheritance (and, by extension, polymorphism) is not a language built-in. A
vtable library will be provided by the standard library to assist in explicit
construction.

## Pointers

The \ character will replace C's -> operator. This is to reduce typing, turning
the common dereference operator into one keystroke instead of three.

    s->x    ===>    s\x

C++'s references (as a replacement for pointers) do not exist.

_clark: I'm starting to come around on the uniform `.` syntax. We should talk._

## To Be Organized

`assert(expr)` will be a compiler built-in. If the expression can be resolved
at compile time, it will be. In release/fast builds, the expression becomes an
assumption for the optimizer. This provides performance incentives to defensive
coding.

No header files, only modules. We can probably rip off D's module system in its
entirety.

Static constructors from D still exist (likely renamed to init(), or
something similar).

Strings are vectors of chars. Conversion to C-strings will be necessary to
talk to C. Much of stdlib's string.h will have to be rewritten.

Anonymous functions can be created with the function keyword.

The "infer" keyword will replace "auto".

All built-in types will have default initialization values; if default
initialization is not wanted, there will be a keyword to prevent
initialization.

Calling conventions will be undefined from function to function; the
compiler/optimizer may choose. This can be overriden if necessary.

There is a "pure" keyword. If a function is pure and unannotated, emit a
diagnostic. If a function is annotated pure and is not, terminate compilation.

"const" stays.

Anonymous structs are a thing; members can be either named, or accessed with
array operators (tuples). A syntax still needs to be decided upon. It should
probably resemble lambdas.

n-conditionals are allowed (e.g. x < y < z = 0).

Nice interfacing with C.

Casting away `const` is illegal - not undefined behavior.

Unit-testing resembles that of D, but has an API accessible from `main()` which
handles test reporting, running, etc. Possibly run tests before `main()` iff
`test_ext` has not been imported. Otherwise, don't run any tests except those
explicitly run by `main()`.

## Compiler Options

* Build types
    * Debug
        * No optimizations, all asserts on.
        * Focus on code making sense in a debugger.
    * Dev (default)
        * Simple optimizations, all asserts on.
        * Focus on lowering the build->test cycle. Compilation should be
          blazing fast, but without sacrificing too much run-time speed. There
          is a delicate middle ground that the Dev build tries to find.
    * Release
        * Full optimization. All asserts on (custom hook enabled).
        * Focus on production-quality code. Build time is not important, and is
          sacrificed to improve quality of shipping code. Asserts are also on,
          but can be hooked by the program to do proper error-reporting.
    * Fast
        * Full optimization. All asserts off.
        * Focus on fast code. That's it. Asserts will be off, and build time
          will be sacrificed for final runtime speed.

Compiler Internals
-------------------

The compiler should be designed modularly, and as a library. The binary will
just be a litle driver (no more than absolutely necessary, such as argument
parsing) to the main compilation library. Then, the compiler library will be
available in stdlib.
