Meta
======

 - Wrap 80 characters/line.
 - Have code samples for every language feature.
 - Indentation with spaces - not tabs.

Points of Contention
====================

Generics should almost never be used. Consider their elimination from the
language, or a serious refactoring.

Consider making only one kind of comment.

"void" is often used simply as a compensation for a mediocre type system. Can
this be eliminated?

Operator-overloading is almost always a bad idea. It should perhaps be
disallowed.

reinterpret\_cast is almost always a bad idea. Its useful points should be
refactored into a safer, better system.

Destructors are often misused, but arguably necessary - can they be improved?

Language Specification
=======================

Objects are POD (pieces of data).

    struct SomeObject
    {
        int a;
        SomeOtherObject b;
        int c;
    }

Any function taking an Object\* as its first parameter can be syntactically
used as a member function of that typed. This can be extended to accomodate
a multiple-dispatch syntax.

Therefore,

    int foo(SomeObject* this, int xZZ, int y)
    {
        ++this\c;
        return x + y + this\a;
    }

    SomeObject bar;
    int z = bar.foo(2, 3);

    SomeObject* pbar = &bar;
    z = pbar\foo(2, 3);

is entirely valid syntax.

There is only one special constructor - the default constructor. This is
defined as a function with the same name as the structure is is
constructing. All built-in structures have a default constructor, and if
one is not provided by the code, the compiler shall create one which calls
the default constructors of each element of the structure.

    struct S
    {
        int a;
        int b;
        int c;
    }

    S s; // all elements are set to zero since the default constructor
         // generated by the compiler sets all ints to zero.

    none S(S* this)
    {
        this\a = 1;
        this\b = 2;
        this\c = 3;
    }

    S s; // in this case, we have a default constructor. s will be { 1, 2, 3 }.

Move constructors do not exist; move constructors should be simple moving
of data.

The \ character will replace the -> operator.

There are no references (as in "transparent" pointers).

No header files, only modules.

Static constructors from D still exist (likely renamed to init(), or
something similar).

Strings are vectors of chars.

Anonymous functions can be created with the function keyword.

The "infer" keyword will replace "auto".

All built-in types will have default initialization values; if default
initialization is not wanted, there will be a keyword to prevent
initialization.

Calling conventions will be undefined from function to function; the
compiler/optimizer may choose. This can be overriden if necessary.

There is a "pure" keyword.

There is a "const" or "immutable" keyword.

Anonymous structs are a thing; members can be either named, or accessed with
array operators (tuples).

n-conditionals are allowed (e.g. x < y < z = 0).

Embedded C and assembly are allowed.

Inheritance (and, by extension, polymorphism) is not a thing.

Const-casting is not a thing.

Unit-testing resembles that of D.

Only three build types: Debug (simple optimizations, focus on quick
compilation), Release (focus on fastest code), -O0 (no optimization
whatsoever).

